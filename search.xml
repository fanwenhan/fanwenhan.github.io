<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法（冒泡排序）]]></title>
    <url>%2F2018%2F06%2F15%2F%E7%AE%97%E6%B3%95%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[内部排序算法：冒泡排序 基本思想将被排序的记录数组R[0..n-1]垂直排列，每个记录R[i]看作是重量为R[i].key的气泡。根据轻气泡不能在重气泡之下的原则，从下往上扫描数组R：凡扫描到违反本原则的轻气泡，就使其 向上”飘浮”。如此反复进行，直到最后任何两个气泡都是轻者在上，重者在下为止。 实现过程 初始状态： ​ R[0..n-1]为无序区。 ​ 第一趟扫描： ​ 从无序区底部向上依次比较相邻的两个气泡的重量，若发现轻者在下、重者 在上，则交换二者的位置，即依次比较(R[n-1], R[n-2])、(R[n-2], R[n-3])、…、(R[1], R[0])；对于每对气泡(R[j+1], R[j])，若R[j+1].key第一趟扫描完毕时，”最轻”的气泡就飘浮到该区间的顶部，即关键字最小的记录被放在最高位置R[0]上。 ​ 第二趟扫描：扫描R[1..n-1]。扫描完毕时，”次轻”的气泡飘浮到R[1]的位置上……最后，经过n-1趟扫描可得到有序区R[0..n-1]。 注意：第i趟扫描时，R[0..i-1]和R[i..n-1]分别为当前的有序区和无序区。扫描仍是从无序区底 部向上直至该区顶部。扫描完毕时，该区中最轻气泡飘浮到顶部位置R[i]上，结果是R[0..i]变为新的有序区。 代码第一种实现(没有优化)1234567891011121314151617181920/** * 冒泡排序的第一种实现, 没有任何优化 * @param a * @param n */public static void bubbleSort1(int [] a, int n)&#123; int i, j; for(i=0; i&lt;n; i++)&#123;//表示n次排序过程。 for(j=1; j&lt;n-i; j++)&#123; if(a[j-1] &gt; a[j])&#123;//前面的数字大于后面的数字就交换 //交换a[j-1]和a[j] int temp; temp = a[j-1]; a[j-1] = a[j]; a[j]=temp; &#125; &#125; &#125;&#125; 第二种实现12345678910111213141516171819202122232425/** * 设置一个标志，如果这一趟发生了交换，则为true，否则为false。明显如果有一趟没有发生交换，说明排序已经完成。 * @param a * @param n */public static void bubbleSort2(int [] a, int n)&#123; int j, k = n; boolean flag = true;//发生了交换就为true, 没发生就为false，第一次判断时必须标志位true。 while (flag)&#123; flag=false;//每次开始排序前，都设置flag为未排序过 for(j=1; j&lt;k; j++)&#123; if(a[j-1] &gt; a[j])&#123;//前面的数字大于后面的数字就交换 //交换a[j-1]和a[j] int temp; temp = a[j-1]; a[j-1] = a[j]; a[j]=temp; //表示交换过数据; flag = true; &#125; &#125; k--;//减小一次排序的尾边界 &#125;//end while&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合概述]]></title>
    <url>%2F2018%2F06%2F15%2F%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Collection(单列集合)List(有序,可重复)​ ArrayList 底层数据结构是数组,查询快,增删慢 线程不安全,效率高 Vector 底层数据结构是数组,查询快,增删慢 线程安全,效率低 LinkedList 底层数据结构是链表,查询慢,增删快 线程不安全,效率高 Set(无序,唯一)​ HashSet 底层数据结构是哈希表。 哈希表依赖两个方法：hashCode()和equals() 执行顺序： 首先判断hashCode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashCode()和equals()即可 ​ LinkedHashSet 底层数据结构由链表和哈希表组成。 由链表保证元素有序。 由哈希表保证元素唯一。 ​ TreeSet 底层数据结构是红黑树。(是一种自平衡的二叉树) 如何保证元素唯一性呢? 根据比较的返回值是否是0来决定 如何保证元素的排序呢? 两种方式 自然排序(元素具备比较性) 让元素所属的类实现Comparable接口 比较器排序(集合具备比较性) 让集合接收一个Comparator的实现类对象 Map(双列集合)​ A:Map集合的数据结构仅仅针对键有效，与值无关。 B:存储的是键值对形式的元素，键唯一，值可重复。 HashMap​ 底层数据结构是哈希表。线程不安全，效率高 哈希表依赖两个方法：hashCode()和equals() 执行顺序： 首先判断hashCode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashCode()和equals()即可 LinkedHashMap​ 底层数据结构由链表和哈希表组成。 由链表保证元素有序。 由哈希表保证元素唯一。 Hashtable​ 底层数据结构是哈希表。线程安全，效率低 哈希表依赖两个方法：hashCode()和equals() 执行顺序： 首先判断hashCode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashCode()和equals()即可 TreeMap​ 底层数据结构是红黑树。(是一种自平衡的二叉树) 如何保证元素唯一性呢? 根据比较的返回值是否是0来决定 如何保证元素的排序呢? 两种方式 自然排序(元素具备比较性) 让元素所属的类实现Comparable接口 比较器排序(集合具备比较性) 让集合接收一个Comparator的实现类对象]]></content>
      <categories>
        <category>技术</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>后端,集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo回顾(一)]]></title>
    <url>%2F2018%2F06%2F12%2Fdubbo%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[dubbo出现dubbo为何出现先说说的一个小插曲 ​ 某公司前期项目使用的是垂直应用框架,即使用SpringMVC+spring+myBatis作为核心开发框架.后期网站的规模越来越大,单纯的几台服务器完全不能满足服务. 年轻的架构师经历了以下的心路历程: 当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。(架构师已经掉了半边头发~) ​ 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，技术老大都不能完整的描述应用的架构关系。(架构师已经成了光头) ​ 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？(架构师拒绝回答该问题,选择宕机) 介绍完这个小小的前提提要,让我们看看dubbo怎么做的 先来自dubbo官方文档: http://dubbo.apache.org/ 网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 单一应用架构一台服务器,一个ORM 1当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 垂直应用架构增加了几台服务器,变为了SpingMVC 1当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 分布式服务架构但是服务器不能无限增加啊(要钱的说),老板就让技术老大想办法.于是就有了核心业务提取,作为独立服务.于是服务器的增加暂停了,同样多的服务器干更多的活 1当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 流动计算架构这部分还没具体接触😂,后面再写…等待更新… 1当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。 优点连通性、健壮性、伸缩性、未来架构的升级。 再有就是看下图:直接将上面的最基本的问题解决 1将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。 架构不说其他的,先看图 说明解释 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。]]></content>
      <categories>
        <category>技术</category>
        <category>doubbo</category>
      </categories>
      <tags>
        <tag>后端,dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么说]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%80%8E%E4%B9%88%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[嘿,姑娘你的男盆友掉了]]></content>
      <categories>
        <category>杂文,随手</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[time]]></title>
    <url>%2F2018%2F06%2F10%2Ftime%2F</url>
    <content type="text"><![CDATA[虽然是时间,但是钱 一首歌 Money is not evil by itself钱本身无罪Its just paper with perceived value to obtain other things we value in other ways钱只是商品流通的交换介质，只是一张纸If not money – what is evil you may ask?那你会问，什么是邪恶？Evil is the unquenchable, obsessive and moral bending desire for more邪恶是上瘾的道德扭曲的欲望Evil is the bottomless, soulless and obsessive-compulsive pursuit of some pot of gold是强迫自己无休止地觊觎at the end of some rainbow which doesn’t exist那些并不存在的梦幻Evil is having a price tag for your heart and soul in exchange for financial success at any cost邪恶是你内心不惜一切代价获取经济利益的价格标签Evil is trying to buy happiness, again and again是贪得无厌，索取幸福until all of those fake, short lived mirages of emotions are gone直到那些虚幻的蜃景消逝Make more time让时间更有意义I’m not saying you can’t be financially successful我并不是说你不能在经济上取得成功I’m saying have a greater purpose in life well beyond the pursuit of financial success我是说有一个伟大的生活目标会超越经济方面的成功Your soul is screaming for you to answer your true calling你的灵魂在尖叫着等你最真切的回应You can change today if you redefine what success is to you如果你重新定义成功，你可能改变自己的现状You can transform your damaged relationships and build new ones你可能改善并重新建立你的人际关系You can forgive yourself and others who’ve hurt you你可能原谅自己和伤害过你的人You can become a leader by mentoring with others who you aspire to be like在你仰慕的人的指导下你也可能成为一个领导You can re-balance your priorities in life你可以重新调整生活的重心You can heal your marriage and recreate a stronger love than you ever thought possible你可以治愈你的婚姻并重建真爱You can become the best parent possible at any age – even 86你在任何年纪都能成为最好的父母，甚至在86岁but don’t wait until then…但千万别等到那时You will always be able to make more money你将来可能会赚很多钱But you cannot make more time却得不到更多时间]]></content>
      <categories>
        <category>杂文,随手</category>
      </categories>
      <tags>
        <tag>歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好,世界]]></title>
    <url>%2F2018%2F06%2F10%2F%E4%BD%A0%E5%A5%BD%2C%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[难得第一次搭建这个blog,对于我很难,因为很多前端内容不熟悉 但是我仍然成功了~]]></content>
      <categories>
        <category>杂文,随手</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
</search>
